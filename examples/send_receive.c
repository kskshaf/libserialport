#include <libserialport.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include "send_receive.h"

#define Timeout   1000
#define BaudRate  4800

IM1281B_PARAM IM1281B_OUT = {
    0,
    0,
    0,
    0,
    0,
    0
};//数据输出结构体实例


/* Example of how to send and receive data.
 *
 * This example file is released to the public domain. */

/* Helper function for error handling. */
int check(enum sp_return result);

uint16_t combine_bytes(unsigned char high, unsigned char low) {
    return (((unsigned short)high) << 8) | low;
}

// Function to calculate Modbus CRC16
// Generated by Claude
uint16_t modbus_crc16(uint8_t *buffer, size_t length) {
    uint16_t crc = 0xFFFF;

    for (size_t i = 0; i < length; i++) {
        crc ^= buffer[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    return crc;
}

void ConvertBytesToUInt32Array(uint8_t* data, uint32_t* output) {
    for (int i = 0; i < 8; i++)
    {
        output[i] = ((uint32_t)data[i * 4] << 24) |
                ((uint32_t)data[i * 4 + 1] << 16) |
                ((uint32_t)data[i * 4 + 2] << 8)  |
                (uint32_t)data[i * 4 + 3];
    }
}

void get_module_data(uint8_t *frame)
{
    uint32_t output[8]={0};
    ConvertBytesToUInt32Array(frame, output);

    IM1281B_OUT.U  = output[0]*0.0001f;
    IM1281B_OUT.I  = output[1]*0.0001f;
    IM1281B_OUT.P  = output[2]*0.0001f;
    IM1281B_OUT.PF = output[4]*0.001f;
	IM1281B_OUT.T  = output[6]*0.01f;
    IM1281B_OUT.F  = output[7]*0.01f;

    printf("[IM1281B] U_in=%f\n", IM1281B_OUT.U);
    printf("[IM1281B] I_in=%f\n", IM1281B_OUT.I);
    printf("[IM1281B] P_in=%f\n", IM1281B_OUT.P);
    printf("[IM1281B] PF_in=%f\n", IM1281B_OUT.PF);
	printf("[IM1281B] T_in=%f\n", IM1281B_OUT.T);
    printf("[IM1281B] F_in=%f\n", IM1281B_OUT.F);
}

int main(int argc, char **argv)
{
    /* This example can be used with one or two ports. With one port, it
     * will send data and try to receive it on the same port. This can be
     * done by connecting a single wire between the TX and RX pins of the
     * port.
     *
     * Alternatively it can be used with two serial ports connected to each
     * other, so that data can be sent on one and received on the other.
     * This can be done with two ports with TX/RX cross-connected, e.g. by
     * a "null modem" cable, or with a pair of interconnected virtual ports,
     * such as those created by com0com on Windows or tty0tty on Linux. */

    /* Get the port names from the command line. */
    if (argc < 2 || argc > 3) {
        printf("Usage: %s <port 1>\n", argv[0]);
        return -1;
    }
    char *port_name = argv[1];

    /* The ports we will use. */
    struct sp_port *port;

    /* Open and configure each port. */
    printf("Looking for port %s.\n", port_name);
    check(sp_get_port_by_name(port_name, &port));

    printf("Opening port.\n");
    check(sp_open(port, SP_MODE_READ_WRITE));

    printf("Setting port to %d 8N1, no flow control.\n", BaudRate);
    check(sp_set_baudrate(port, BaudRate));
    check(sp_set_bits(port, 8));
    check(sp_set_parity(port, SP_PARITY_NONE));
    check(sp_set_stopbits(port, 1));
    check(sp_set_rts(port, SP_RTS_OFF));
    check(sp_set_cts(port, SP_CTS_IGNORE));
    check(sp_set_dtr(port, SP_DTR_OFF));
    check(sp_set_dsr(port, SP_DSR_IGNORE));
    check(sp_set_flowcontrol(port, SP_FLOWCONTROL_NONE));

    /* Now send some data on each port and receive it back. */
    /* Get the ports to send and receive on. */

    /* The data we will send. */
    int size = sizeof(data_send);

    /* We'll allow a 1 second timeout for send and receive. */
    //unsigned int timeout = 1000;

    /* On success, sp_blocking_write() and sp_blocking_read()
        * return the number of bytes sent/received before the
        * timeout expired. We'll store that result here. */
    int result;

    /* Send data. */
    printf("Sending (%d bytes) on port %s.\n", size, port_name);
    result = check(sp_blocking_write(port, data_send, size, Timeout));

    //usleep(250000);
    /* Check whether we sent all of the data. */
    if (result == size)
        printf("Sent %d bytes successfully.\n", size);
    else
        printf("Timed out, %d/%d bytes sent.\n", result, size);

    /* Allocate a buffer to receive data. */
    uint32_t receive_size = 37;
    uint8_t  *buf = malloc(receive_size + 1);

    /* Try to receive the data on the other port. */
    printf("Receiving %d bytes on port %s.\n", receive_size, port_name);
    result = check(sp_blocking_read(port, buf, receive_size, Timeout));

    /* Check whether we received the number of bytes we wanted. */
    if (result == receive_size)
        printf("Received %d bytes successfully.\n", receive_size);
    else
        printf("Timed out, %d/%d bytes received.\n", result, receive_size);

    /* Check if we received the same data we sent. */
    buf[result] = '\0';
    //printf("Received '%s'.\n", buf);

    // https://stackoverflow.com/questions/30225423/send-hex-values-via-serial-port-in-c
    // https://github.com/tree-water/acac/blob/main/Core/Src/IM1281B.c
    uint8_t crc_non_data[receive_size - 2];
	uint8_t main_data[receive_size - 5];
    for(int j=0; j < (receive_size - 2); j++)
    {
        crc_non_data[j] = buf[j];
        if(j < (receive_size - 5)) main_data[j] = buf[j+3];
    }

    uint16_t data_crc = modbus_crc16(crc_non_data, sizeof(crc_non_data));
    if(combine_bytes(buf[receive_size - 1], buf[receive_size - 2]) != data_crc)
    {
        printf("DATA CRC NOT MATCH!\n");
    }
    else
    {
        printf("DATA CRC OK!\nHex data: ");
        for(int i = 0; i < receive_size; i++) {
            printf("%02X ", buf[i]);
        }
        printf("\n\n");
		get_module_data(main_data);
    }

    /* Free receive buffer. */
    free(buf);

    /* Close ports and free resources. */
    check(sp_close(port));
    sp_free_port(port);

    return 0;
}

/* Helper function for error handling. */
int check(enum sp_return result)
{
    /* For this example we'll just exit on any error by calling abort(). */
    char *error_message;

    switch (result) {
    case SP_ERR_ARG:
        printf("Error: Invalid argument.\n");
        abort();
    case SP_ERR_FAIL:
        error_message = sp_last_error_message();
        printf("Error: Failed: %s\n", error_message);
        sp_free_error_message(error_message);
        abort();
    case SP_ERR_SUPP:
        printf("Error: Not supported.\n");
        abort();
    case SP_ERR_MEM:
        printf("Error: Couldn't allocate memory.\n");
        abort();
    case SP_OK:
    default:
        return result;
    }
}
